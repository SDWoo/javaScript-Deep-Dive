# ES6 이전 함수들의 문제

> 함수가 일반 함수로써도 호출이 가능하고 생성자 함수로써도 호출 가능했다.

- 객체에 바인딩된 함수일 경우
  - 생성자 함수로 호출하면 불필요한 프로토타입 객체 생성
- 콜백 함수의 경우
  - 콜백 함수도 constructor이기 때문에 불필요한 프로토타입 객체 생성

<br />

# 메서드

> ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.

- ES6 사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor이다.
- prototype 프로퍼티가 없고, 프로토타입도 생성하지 않는다.
  - 자신을 바인딩한 객체를 가리키기 위해 [[HomeObject]]를 갖는다.
  - ES6 메서드가 아니면 super을 사용할 수 없다.

<br />

# 화살표 함수

> 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용

- 화살표 함수와 일반 함수의 차이
  - 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor 이다.
  - 중복된 매개변수 이름을 선언할 수 없다.
  - 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

```
1. this
- 화살표 함수와 일반 함수가 구별되는 가장 큰 특징
- 고차함수의 콜백 함수는 일반 함수로써 호출하는데, 일반함수로써 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다.
- 그런데 strict-mode가 적용되어 일반함수로써 호출된 모든 함수 내부의 this는 undefined가 되어버린다.
- 해결법
    - ES5
    1. this를 먼저 빼놓고 시작.
    2. this를 고차함수의 두번째 인자로 씀
    3. Function.prototype.bind로 this를 바인딩

    -ES6
    - 화살표 함수 써버리면 끝
        - 화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로 상위 스코프의 this를 그대로 참조 (lexical this)
        - 화살표 함수가 중첩되어 있는 경우에는 상위에서 가장 가까운 (화살표 함수 가 아닌) 스코프의 this 참조.

* super와 arguments도 똑같이 바인딩이 없으므로 상위 스코프 참조한다.
```

- 메서드를 화살표 함수로 정의하는 것은 피해야 함.

<br />

# Rest 파라미터

> Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

- Rest 파라미터는 가장 뒤에 위치해야 한다.
- Rest 파라미터는 단 하나만 선언할 수 있다.
- Rest 파라미터는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.

```
ES5 - arguments객체로 인수들을 관리했는데, 유사 배열 객체라서 배열 메서드를 사용하러면 배열로 바꿔야했음
ES6 - rest 파라미터 이용해서 인수 목록을 배열로 직접 전달받을 수 있다. 배열로 안바꿔서 굳이다.
* 화살표 함수는 반드시 rest 파라미터 이용해서 인수 목록을 받아야한다.
```

- 매개변수 기본값

* 전달을 제대로 안할 시 undefined
* undefined 일시 기본 값을 저장할 수 있는데, 그건 length, arguments에 영향 X
