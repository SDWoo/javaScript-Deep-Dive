- 이벤트 타입
1. 마우스 이벤트: click, dbclick, mouse(up, down, move, enter, over, leave, out)
2. 키보드 이벤트: key(down, up), *keypress는 폐지 되어 안쓰길 권장
3. 포커스 이벤트: focus, blur, focus(in, out)
4. 폼 이벤트: submit, reset
* 그 외 : 값 변경 이벤트(input, change, readystatechange), DOM뮤테이션 이벤트(DOMContentLoaded), 뷰 이벤트(resize=> window, scroll), 리소스 이벤트(load, unload, abort, error)

- 이벤트 드리븐 프로그래밍: 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식
=> 이벤트: 브라우저가 처리해야할 특정 사건을 발생하면 이를 감지하여 발생시키는 것.
=> 이벤트 핸들러: 이벤트가 발생했을 때 호출될 함수
=> 이벤트 핸들러 등록: 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것

- 이벤트 핸들러 등록
1. 이벤트 핸들러 어트리뷰트 방식: 어트리뷰트에 on접두사와 이벤트의 종류를 나타내는 이벤트 타입으로 등록 (함수 참조가 아닌 문을 할당함)
=> 함수가 아닌 값을 반환하는 함수 호출문을 이벤트 핸들러 등록하면 브라우저가 호출 불가 -> 이 어트리뷰트 값은 그 함수 몸체를 의미한다. (사용하지 않는게 좋다, 근데 프레임워크 라이브러리에서 씀)
2. 이벤트 핸들러 프로퍼티 방식: 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩 시킨다. 
=> HTML와 javaScript가 뒤섞이는 문제 해결, but 하나의 핸들러만 바인딩 가능
3. addEventListener메서드 방식: 이벤트 핸들러를 인수로 전달한다. (함수를 전달해야 되니 핸들러에 ()안붙임)
=> 두 개 이상의 핸들러 등록도 가능하며 순서대로 실행된다. (참조가 동일한 이벤트 핸들러 중복 등록하면 하나만 등록)

- 이벤트 핸들러 제거
1. removeEventListener: addEventListener와 동일한 인수 (이벤트 핸들러가 일치하면 제거, or not)
=> 무명함수 제거 불가(arguments.callee로 가능), 이벤트 핸들러 프로퍼티 방식으로 등록한 핸들러 제거 불가.
=> 기명 이벤트 핸들러 내부에서 제거 할 경우 이벤트 핸들러 한번만 실행.

- 이벤트 객체
=> 이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성. (이벤트 핸들러의 첫 번째 인수로 전달)
Ex) 자주 사용하던 e.target 의 e가 이벤트 객체
=> 이벤트 객체는 어떤 이벤트 타입이냐에 따라 다른 객체를 생성한다.
=> 공통 프로퍼티들이 있다. (Type, target, currentTarget …);
* 마우스 정보 취득: 마우스 이벤트가 발생하면 MouseEvent 타입의 이벤트 객체는 고유의 프로퍼티를 갖는다.
* 키보드 정보 취득: 키보드 이벤트가 발생하면 KeyboardEvent 타입의 이벤트 객체 또한 고유의 프로퍼티를 갖는다.

- 이벤트 전파: DOM트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트가 DOM 트리를 통해 전파되는 것.
Ex) body태그 내의 ul 태그 내의 li 클릭 
1. 캡처링 페이즈 => window -> document -> html -> body -> ul -> li (이벤트(객체)가 상위 요소에서 하위 요소 방향으로 전파)
2. 타겟 페이즈: 이벤트(객체)가 이벤트 타깃에 동작
3. 버블링 페이즈 => li -> ul -> body ->  html -> document -> window (이벤트(객체)가 하위 요소에서 상위 요소 방향으로 전파)
=> 이벤트 핸들러 어트리뷰트/ 프로퍼티 방식으로는 타깃 단계와 버블링 단계의 이벤트만 캐리 가능.
But, addEventListener 메서드 방식은 세번째 인자가 true인 경우 캡처링 단계의 이벤트도 선별적으로 캐리 가능

* 이벤트는 이벤트를 발생시킨 이벤트 타깃을 물론 상위DOM 요소에서도 캐치할 수 있다.
* 버블링을 통해 전파되지 않는 이벤트: 포커스, 리소스, 마우스 이벤트 (캡처링 단계의 이벤트를 캐리해야 함)
=> 이 경우에도 버블링을 통해 전파되는 대체 방식들이 있음 (blur/focus -> focus(in/out), mouse(enter/leave) -> mouse(over/out))
=> 이벤트 호출 순서: 캡처링 단계 캐치하는 이벤트 핸들러 -> 타겟 -> 버블링 단계 캐치하는 이벤트 핸들러

- 이벤트 위임: 여러개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법
=> 이벤트 타깃은 상위 DOM 요소에서도 캐치 가능. 
* currentTarget 프로퍼티와 target의 DOM요소가 다를 수 있음

* 이벤트 기본 동작 조작
1. event(객체).preventDefault() => 기본 동작 무시 (form태그 자동으로 화면전환할때 썼던듯)
2. event(객체).stopPropagation() => 상위 DOM요소에 이벤트를 위임한 경우에 하위 DOM 요소 중 이벤트 전파를 막고 자체적으로 이벤트를 처리하고 싶은 경우

* 이벤트 핸들러 내부의 this
1. 이벤트 핸들러 어트리뷰트 방식: this는 window (전역 객체) 가리키고, 이벤트 핸들러 호출할 때 this는 이벤트를 바인딩한 DOM 요소
2. 이벤트 핸들러 프로퍼티 방식과 addEventListener방식: 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM요소 가리킴
* 화살표 함수로 정의한 이벤트 핸들러 내부의 this 는 상위 스코프의 this (화살표 함수는 자체 this바인딩 갖지 않기 때문)
* 클래스에서의 경우에 이벤트 핸들러 내부의 this는 바인딩 된 DOM 요소를 가리키기 때문에 bind 메서드를 사용해 this를 전달해야 해서 생성할 인스턴스를 가리키도록 해야 한다. or 화살표 함수
* 이벤트 핸들러에 인수 전달: 화살표 함수 내부에 한번 더 해서 전달
